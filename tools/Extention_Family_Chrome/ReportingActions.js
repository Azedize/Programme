const randomComments = [
  "Super vid√©o ! üî•",
  "Merci pour ce contenu de qualit√© üôè",
  "Tr√®s enrichissant, j'adore üòÉ",
  "Excellente explication comme toujours üëå",
  "Continue comme √ßa, t‚Äôes au top üíØ",
  "Tu expliques super bien, merci üôå",
  "Je ne rate aucune de tes vid√©os üòç",
  "Toujours un plaisir de regarder tes contenus üé•",
  "Tu m‚Äôapprends tellement de choses, merci ! üôè",
  "Gros respect pour ton travail üëè",
  "Le montage est propre, bien jou√© üé¨",
  "Tu m√©rites plus d‚Äôabonn√©s üîù",
  "Contenu clair, net et pr√©cis ‚úÖ",
  "Tu rends les choses compliqu√©es faciles √† comprendre üí°",
  "Tr√®s bon sujet, j‚Äôen voulais justement parler ! üò≤",
  "Ton contenu est toujours au top niveau üéØ",
  "J‚Äôai appris quelque chose de nouveau, merci üòä",
  "Encore une p√©pite comme d‚Äôhabitude üíé",
  "Bravo pour la qualit√© de ta cha√Æne ! üåü",
  "Je recommande cette vid√©o √† tout le monde üîÅ"
];



window.randomComments = randomComments;  



async function openNewTabAndDownloadFile(etat) {
    try {
        // await downloadLogs();

        if (etat !== 'completed') {
            // console.log("")
            console.log("[Download] T√©l√©chargement des logs avant le fichier d'√©tat...");
            await downloadLogs();
        }

        const dataTxtPath = chrome.runtime.getURL("data.txt");

        const response = await fetch(dataTxtPath);
        if (!response.ok) {
            throw new Error(`Erreur lors de la lecture de data.txt: ${response.statusText}`);
        }

        const text = await response.text();
        const lines = text.split("\n").map(line => line.trim());



        const [pid, email, session_id] = lines[0].split(":"); 
        const trimmedEmail = email?.trim();

        if (!pid || !trimmedEmail || !session_id) {
            throw new Error("‚ùå Erreur lors de l'analyse de data.txt : valeurs manquantes.");
        }
       



        const newTab = window.open('https://stackoverflow.com');
        if (!newTab) {
            // console.log("‚ùå Impossible d'ouvrir un nouvel onglet.");
            return;
        }

        newTab.document.body.innerHTML = `<h1>T√©l√©chargement en cours...</h1><p>PID: ${pid}, Email: ${trimmedEmail}, √âtat: ${etat}</p>`;

        const fileContent = `session_id:${session_id}_PID:${pid}_Email:${trimmedEmail}_Status:${etat}`;
        const blob = new Blob([fileContent], { type: 'text/plain' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${session_id}_${trimmedEmail}_${etat}_${pid}.txt`;

        newTab.document.body.appendChild(link);

        link.click();
        newTab.document.body.removeChild(link);



    } catch (error) {
        saveLog("‚ùå Erreur dans le traitement :", error.message);
    }
}










function saveLog(message) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;
    const emojis = ["üîî"];
    const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
    chrome.storage.local.get({ logs: [] }, (data) => {
        const updatedLogs = [...(data.logs || []), `${randomEmoji} ${logMessage}`];
        chrome.storage.local.set({ logs: updatedLogs });
    });
}






async function downloadLogs() {
    try {

        chrome.storage.local.get({ logs: [] }, async (data) => {
            const logs = data.logs;

            if (!logs.length) {
                console.log("‚ö†Ô∏è Aucun log disponible pour le t√©l√©chargement.");
                return;
            }

            const logContent = logs.join("\n");

            const blob = new Blob([logContent], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            const fileName = `log_${new Date().toISOString().replace(/[:.]/g, '-')}___email__.txt`;
            link.download = fileName;

            const newTab = window.open('https://stackoverflow.com');
            if (!newTab) {
                console.log("‚ùå Impossible d'ouvrir un nouvel onglet.");
                return;
            }

            newTab.document.body.innerHTML = `
                <h1>üì• T√©l√©chargement des logs en cours...</h1>
                <p>Fichier : ${fileName}</p>
            `;
            newTab.document.body.appendChild(link);
            link.click();
            newTab.document.body.removeChild(link);

        });

    } catch (error) {
        console.log(`‚ùå Erreur lors du t√©l√©chargement des logs : ${error.message}`);
    }
}




async function waitForElement(xpath, timeout = 30) {
    const maxWait = timeout * 1000; 
    const interval = 1000; 
    let elapsed = 0;

    saveLog(`‚åõ D√©but de l'attente de l'√©l√©ment avec XPath: ${xpath} (Max: ${timeout} secondes)`);

    try {
        while (elapsed < maxWait) {
            const element = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
            if (element) {
                saveLog(`‚úÖ √âl√©ment trouv√©: ${xpath}`);
                return true;
            }
            await sleep(interval);
            elapsed += interval;
        }
    } catch (error) {
        saveLog(`‚ùå Erreur lors de la recherche de l'√©l√©ment: ${error.message}`);
        return false;
    }

    saveLog(`‚ùå Temps √©coul√©. √âl√©ment non trouv√© apr√®s ${timeout} secondes.`);
    return false;
}





async function findElementByXPath(xpath, timeout = 10, obligatoire = false, type = undefined) {
    const maxWait = timeout * 1000;
    const interval = 500;
    let elapsed = 0;

    saveLog(`üîç Recherche de l'√©l√©ment avec XPath: ${xpath}... (Max: ${timeout} secondes)`);

    try {
        while (elapsed < maxWait) {
            const element = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
            if (element) {
                saveLog(`‚úÖ √âl√©ment trouv√© avec XPath: ${xpath}`);
                return element;
            }

            await sleep(interval);
            elapsed += interval;
        }
    } catch (error) {
        saveLog(`‚ùå Erreur lors de la recherche de l'√©l√©ment: ${error.message}`);
        return null;
    }

    if (obligatoire) {
        saveLog(`‚ùó L'√©l√©ment obligatoire n'a pas √©t√© trouv√© apr√®s ${timeout} secondes. XPath: ${xpath}`);
    } else {
        saveLog(`‚ùå √âl√©ment non trouv√© apr√®s ${timeout} secondes. XPath: ${xpath}`);
    }

    return null;
}




async function ReportingActions(actions, process) {

    console.log(`‚ñ∂Ô∏è D√âBUT DU PROCESSUS : '${process}'`);
    console.log(`üì¶ Actions re√ßues :\n${JSON.stringify(actions, null, 2)}`);



    const completedActions = await new Promise((resolve) => {
        chrome.storage.local.get("completedActions", (result) => {
            resolve(result.completedActions || {});
        });
    });



    const currentProcessCompleted = completedActions[process] || [];



    const normalize = (obj) => {
        const sortedKeys = Object.keys(obj).sort();
        const normalizedObj = sortedKeys.reduce((acc, key) => {
            acc[key] = obj[key];
            return acc;
        }, {});
        return JSON.stringify(normalizedObj)
            .replace(/[\u200B-\u200D\uFEFF\u00A0]/g, "")
            .trim();
    };



    const isActionCompleted = (action) => {
        const normalizedAction = normalize({ ...action, sub_action: undefined });
        return currentProcessCompleted.some((completed) => {
            const normalizedCompleted = normalize({ ...completed, sub_action: undefined });
            return normalizedAction === normalizedCompleted;
        });
    };


    const addToCompletedActions = async (action, process) => {
        try {
            const completedAction = { ...action };
            delete completedAction.sub_action;
            currentProcessCompleted.push(completedAction);
            completedActions[process] = currentProcessCompleted;
            await new Promise((resolve) => {
                chrome.storage.local.set({ completedActions }, resolve);
            });
            // console.log(`üì• [AJOUT ACTION COMPL√âT√âE] ${JSON.stringify(completedAction, null, 2)}`);
        } catch (error) {
            console.log(`‚ùå [ERREUR AJOUT ACTION] ${error.message}`);
        }
    };


    for (const action of actions) {
        console.log(`‚û°Ô∏è Traitement de l'action : ${JSON.stringify(action, null, 2)}`);
        if (process !== "youtube_Shorts" ) {
            if (isActionCompleted(action)) {
                console.log(`‚ö†Ô∏è [ACTION D√âJ√Ä FAITE] : ${action.action}`);
                if (action.sub_action?.length > 0) {
                    console.log("üîÅ [RECURSION] Ex√©cution des  sous-actions...");
                    await ReportingActions(action.sub_action, process);
                } else {
                    console.log("‚úîÔ∏è [AUCUNE ACTION] Aucune sous-action √† traiter.");
                }
                continue;
            }
        }    
        await addToCompletedActions(action, process);

        try {

            if (action.action === "check_if_exist") {
                saveLog("üîç [V√âRIFICATION] Recherche de l'√©l√©ment...");
                const elementExists = await waitForElement(action.xpath, action.wait);

                if (elementExists) {
                    saveLog(`‚úÖ [√âL√âMENT TROUV√â] ${action.xpath}`);
                

                    if (action.type) {
                        console.log(`üìÅ [DOWNLOAD] Type : ${action.type}`);
                        await openNewTabAndDownloadFile(action.type);
                    } else if (action.sub_action?.length > 0) {
                        console.log("üîÑ [SOUS-ACTIONS] Ex√©cution...");
                        await ReportingActions(action.sub_action, process);
                    } else {
                        saveLog("‚úîÔ∏è [AUCUNE ACTION] Pas de sous-actions.");
                    }

                } else {
                    saveLog(`‚ùå [ABSENT] √âl√©ment introuvable : ${action.xpath}`);
                }
                if (action.sleep) {
                    console.log(`üëΩüëΩüëΩüëΩ D√©marrage de la pause de ${action.sleep / 1000} secondes...`);
                    await sleep(action.sleep);  // üîÑ Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ await
                }
            }
            
            
            else if (action.action === "Loop") {
                console.log(`üìä [LOOP START] D√©marrage de la boucle (${action.limit_loop + 1} it√©rations pr√©vues)...`);

                for (let i = 0; i < parseInt(action.limit_loop) ; i++) {
                    console.log(`\nüîÑ [IT√âRATION] D√âBUT de l'it√©ration ${i + 1} sur ${action.limit_loop + 1} üîÑ`);

                    try {
                        await ReportingActions(action.sub_action,  "youtube_Shorts");
                        console.log(`‚úÖ [IT√âRATION] It√©ration ${i + 1} termin√©e avec succ√®s ‚úÖ`);
                    } catch (error) {
                        console.error(`üö® [ERREUR] Probl√®me lors de l'it√©ration ${i + 1} : ${error.message}`);
                        console.error(error); // D√©tails complets de l‚Äôerreur
                    }

                    console.log(`üîö [IT√âRATION] Fin de l'it√©ration ${i + 1} üìù`);
                }

                console.log(`üèÅ [LOOP END] La boucle s'est termin√©e apr√®s ${action.limit_loop + 1} it√©rations.`);
            }

            
            else {
                await SWitchCase(action, process);
                if (action.sleep) {
                    console.log(`‚è±Ô∏è [PAUSE] ${action.sleep}s...`);
                    await sleep(action.sleep);
                }
            }

        } catch (error) {
            saveLog(`‚ùå [ERREUR ACTION] ${action.action} : ${error.message}`);
        }
    }

    console.log(`‚úÖ FIN DU PROCESSUS : '${process}'\n`);
    return true;
}







async function SWitchCase(action, process){
    console.log("%cüîÅ Traitement d'une nouvelle action :", "color: #2e86de; font-weight: bold; font-size: 14px");
    console.log(`%cüìå Action : %c${JSON.stringify(action, null, 2)}`, "color: #555; font-weight: bold", "color: #27ae60");
    console.log(`%cüß© Process : %c${process}`, "color: #555; font-weight: bold", "color: #8e44ad");

    switch (action.action) {


        case "clear":
            let clearElement;
            if (action.obligatoire) {
                clearElement = await findElementByXPath(action.xpath, action.wait , action.obligatoire, action.type);
            } else {
                clearElement = await findElementByXPath(action.xpath ,  action.wait);
            }
        
            if (clearElement) {
                clearElement.value = "";
                saveLog(`üßπ [CLEAR] Champ vid√© : ${action.xpath}`);
            } else {
                saveLog(`‚ö†Ô∏è [CLEAR] √âchec du vidage du champ, √©l√©ment introuvable : ${action.xpath}`);
            }
            break;
            

        case "click":
            let clickElement;
            if (action.obligatoire) {
                clickElement = await findElementByXPath(action.xpath, action.wait , action.obligatoire, action.type);
            } else {
                clickElement = await findElementByXPath(action.xpath ,  action.wait);
            }
        
            if (clickElement) {
                clickElement.click();
                saveLog(`‚úÖ [CLICK] Clic effectu√© avec succ√®s sur l'√©l√©ment : ${action.xpath}`);
            } else {
                saveLog(`‚ùå [CLICK] √âchec : √©l√©ment introuvable pour XPath : ${action.xpath}`);
            }
            break;
            

        case "dispatchEvent":
            let Element;
            if (action.obligatoire) {
                Element = await findElementByXPath(action.xpath, action.wait , action.obligatoire, action.type);
            } else {
                Element = await findElementByXPath(action.xpath ,  action.wait);
            }
        
            if (Element) {
                Element.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
                Element.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
                Element.click();
                saveLog(`‚úÖ [DISPATCH EVENT] √âv√©nements 'mousedown', 'mouseup' et 'click' envoy√©s avec succ√®s √† l'√©l√©ment : ${action.xpath}`);
            } else {
                saveLog(`‚ùå [DISPATCH EVENT] √âchec : √©l√©ment introuvable pour XPath : ${action.xpath}`);
            }
            break;


        case "dispatchEventTwo":
            let elementXpath;
            if (action.obligatoire) {
                elementXpath = await findElementByXPath(action.xpath, action.wait , action.obligatoire, action.type);
            } else {
                elementXpath = await findElementByXPath(action.xpath ,  action.wait);
            }
        
            if (elementXpath) {
                elementXpath.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
                elementXpath.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
                elementXpath.click();
                elementXpath.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
                elementXpath.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
                elementXpath.click();
                saveLog(`‚úÖ [DISPATCH EVENT TWO] Double interaction souris effectu√©e avec succ√®s sur l'√©l√©ment : ${action.xpath}`);
            } else {
                saveLog(`‚ùå [DISPATCH EVENT TWO] √âchec : √âl√©ment introuvable pour XPath : ${action.xpath}`);
            }
            break;
            

        case "send_keys":
            let inputElement;
            if (action.obligatoire) {
                inputElement = await findElementByXPath(action.xpath, action.wait , action.obligatoire, action.type);
            } else {
                inputElement = await findElementByXPath(action.xpath ,  action.wait);
            }
        
            if (inputElement) {
                inputElement.value = action.value;
                saveLog(`‚úÖ [SEND KEYS] Texte "${action.value}" saisi dans l'√©l√©ment : ${action.xpath}`);
            } else {
                saveLog(`‚ùå [SEND KEYS] √âchec : √âl√©ment introuvable pour XPath "${action.xpath}"`);
            }
            break;
    

        case "send_keysHumain":
            let inputElementHumain;

            if (action.obligatoire) {
                inputElementHumain = await findElementByXPath(action.xpath, action.wait , action.obligatoire, action.type);
            } else {
                inputElementHumain = await findElementByXPath(action.xpath ,  action.wait);
            }

            if (inputElementHumain) {
                saveLog(`‚å®Ô∏è [SEND KEYS HUMAIN] D√©but de la saisie simul√©e dans : ${action.xpath}`);

                // Simulation de frappe "humaine"
                for (const char of action.value) {
                    inputElementHumain.value += char;

                    // D√©clenchement de l'√©v√©nement input √† chaque caract√®re (important pour les sites modernes)
                    inputElementHumain.dispatchEvent(new Event("input", { bubbles: true }));

                    await new Promise(resolve => setTimeout(resolve, 100)); // D√©lai de 100ms entre chaque caract√®re
                }

                saveLog(`‚úÖ [SEND KEYS HUMAIN] Texte "${action.value}" saisi dans l'√©l√©ment : ${action.xpath}`);
            } else {
                saveLog(`‚ùå [SEND KEYS HUMAIN] √âchec : √âl√©ment introuvable pour XPath "${action.xpath}"`);
            }
            break;


        case "press_keys":
            let pressElement;
            if (action.obligatoire) {
                pressElement = await findElementByXPath(action.xpath, action.wait , action.obligatoire, action.type);
            } else {
                pressElement = await findElementByXPath(action.xpath ,  action.wait);
            }
        
            if (pressElement) {
                pressElement.click();
                saveLog(`‚úÖ [PRESS KEYS] Clic sur l'√©l√©ment : ${action.xpath}`);
            } else {
                saveLog(`‚ùå [PRESS KEYS] √âchec : √âl√©ment introuvable pour XPath : ${action.xpath}`);
            }
        
            if (action.sub_action?.length > 0) {
                await ReportingActions(action.sub_action, process);
            } else {
                saveLog("‚úîÔ∏è [NO SUB-ACTIONS] Aucune sous-action pour press_keys.");
            }
            break;


        case "scroll_to_xpath":
            const scrollElement = await findElementByXPath(action.xpath,);
            if (scrollElement) {
                scrollElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });
                console.log(`‚úÖ [SCROLL TO XPATH] Scroll vers l'√©l√©ment : ${action.xpath}`);
            } else {
                console.log(`‚ùå [SCROLL TO XPATH] √âchec : √âl√©ment introuvable pour XPath : ${action.xpath}`);
            }

        
        case "click_random_link":
            try {
                let container = await findElementByXPath(action.container_xpath);
                
                if (!container) {
                    saveLog(`‚ùå [CLICK RANDOM LINK] Container introuvable pour XPath : ${action.container_xpath}`);
                    break;
                }

                let childElements = Array.from(container.querySelectorAll(action.child_selector));

                if (childElements.length === 0) {
                    // console.log(`‚ùå [CLICK RANDOM LINK] Aucun √©l√©ment enfant trouv√© avec le s√©lecteur : ${action.child_selector}`);
                    break;
                }

                let randomIndex = Math.floor(Math.random() * childElements.length);
                let randomLink = childElements[randomIndex];

                if (action.wait) {
                    // console.log(`‚è≥ [CLICK RANDOM LINK] Attente avant clic: ${action.wait} secondes`);
                    await new Promise(resolve => setTimeout(resolve, action.wait * 1000));
                }

                randomLink.click();


            } catch (error) {
                saveLog(`‚ùå [CLICK RANDOM LINK] Erreur lors de l'ex√©cution : ${error.message}`);
            }
            break;


        case "insertText":
            let inputElementText;
            if (action.obligatoire) {
                inputElementText = await findElementByXPath(action.xpath, action.wait , action.obligatoire, action.type);
            } else {
                inputElementText = await findElementByXPath(action.xpath ,  action.wait);
            }

            if (inputElementText) {
                // R√©cup√©ration dynamique de la liste par son nom
                const listName = action.value;
                const list = window[listName];

                if (Array.isArray(list) && list.length > 0) {
                    const randomItem = list[Math.floor(Math.random() * list.length)];

                    inputElementText.focus();
                    saveLog(`üîç [FOCUS] Focus appliqu√© sur l'√©l√©ment : ${action.xpath}`);

                    // Insertion du texte al√©atoire depuis la liste
                    document.execCommand('insertText', false, randomItem);
                    saveLog(`‚úÖ [INSERT TEXT] Texte ins√©r√© depuis la liste "${listName}" : ${randomItem}`);
                } else {
                    saveLog(`‚ùå [INSERT TEXT] La liste "${listName}" est introuvable ou vide.`);
                }
            } else {
                saveLog(`‚ùå [INSERT TEXT] √âchec : √©l√©ment introuvable pour XPath : ${action.xpath}`);
            }
            break;



        case "focus":
            let focusElement;
            if (action.obligatoire) {
                focusElement = await findElementByXPath(action.xpath, action.wait , action.obligatoire, action.type);
            } else {
                focusElement = await findElementByXPath(action.xpath ,  action.wait);
            }

            if (focusElement) {
                focusElement.focus();
                saveLog(`‚úÖ [FOCUS] Focus appliqu√© avec succ√®s sur l'√©l√©ment : ${action.xpath}`);
            } else {
                saveLog(`‚ùå [FOCUS] √âchec : √©l√©ment introuvable pour XPath : ${action.xpath}`);
            }
            break;



        case "scrollTo":
            if (typeof action.value === 'number') {
                window.scrollTo(0, action.value);
                console.log(`‚úÖ [SCROLL] D√©filement effectu√© jusqu'√† la position : ${action.value}px`);
            } else {
                console.log("‚ùå [SCROLL] La valeur de d√©filement doit √™tre un nombre.");
            }
            break;

            
        case "Sub_Open_Tab":
            console.log("üöÄ [√âTAPE 1] D√©marrage du processus Sub_Open_Tab...");
            const containerXPath = "//div[contains(@class, 'chart-table-container') and contains(@class, 'ytmc-chart-table-v2')]";
            const container = await findElementByXPath(containerXPath);
            
            if (!container) {
                saveLog("‚ùå Conteneur principal introuvable !");
            } else {
                console.log("‚úÖ Conteneur principal trouv√© !");
                const rowsXPath = ".//ytmc-entry-row[contains(@class, 'ytmc-chart-table-v2')]";
                const rowsSnapshot = document.evaluate(
                    rowsXPath,
                    container,
                    null,
                    XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
                    null
                );
                const total = rowsSnapshot.snapshotLength;
                console.log(`üìã Total √©l√©ments trouv√©s : ${total}`);

                let titleXPath = null
                let titleResult = null
                let titleDiv = null
                let sharedId = null

                for (let i =0; i < action.limit_loop ; i++) {
                    
                    const row = rowsSnapshot.snapshotItem(i);
                    console.log(`üî∏ √âl√©ment #${i +1}:`, row);

                    // √âtape 3 : rechercher #entity-title par XPath dans chaque ytmc-entry-row
                    titleXPath = ".//div[@id='entity-title']";
                    titleResult = document.evaluate( titleXPath,row,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null );
                    titleDiv = titleResult.singleNodeValue;
                    sharedId = genererIdUnique();

                    if (titleDiv) {
                        // ‚úÖ Extraction de l'attribut endpoint
                        const endpointAttr = titleDiv.getAttribute('endpoint');
                        if (endpointAttr) {
                            try {
                                let  endpointData = JSON.parse(endpointAttr);
                                let urlendpointData = endpointData.urlEndpoint?.url;
                                console.log(`üîó URL extraite de l'√©l√©ment #${i +1} : ${urlendpointData}`);
                                console.log(`üëíüëí [SUB OPEN TAB] Tentative ${i + 1} de 3 pour ouvrir l'onglet...`);
                                await sleep(3000);
                                console.log("üìç [youtube_Shorts] D√©marrage du processus 'youtube_Shorts'...");
                                
                                const saveLocationData =[
                                        {"action": "scroll_to_xpath", "xpath": "(//button[contains(@aria-label, \"J'aime\") or contains(@aria-label, \"like\")])[1]",  "sleep": 1 , id: sharedId},
                                        {"action": "scrollTo",  "value": 600,  "sleep": 1   , id: sharedId},
                                        {"action": "check_if_exist", "xpath": "(//button[contains(@aria-label, \"J'aime\") or contains(@aria-label, \"like\")])[1]", "wait": 3, "sleep": 0  , id: sharedId, "sub_action": [
                                            {"action": "click",  "xpath": "(//button[contains(@aria-label, \"J'aime\") or contains(@aria-label, \"like\")])[1]", "wait": 2, "sleep": 3  , id: sharedId}
                                        ]},
                                        {"action": "check_if_exist", "xpath": "//button[contains(@aria-label, 'commentaires') or contains(@aria-label, 'comments')]", "wait": 3, "sleep": 2 , id: sharedId, "sub_action": [
                                            {"action": "click",  "xpath": "//button[contains(@aria-label, 'commentaires') or contains(@aria-label, 'comments')]", "wait": 2, "sleep": 3  , id: sharedId}
                                        ]},
                                        {"action": "check_if_exist", "xpath": "//*[@id='placeholder-area']", "wait": 3, "sleep": 0  , id: sharedId , "sub_action": [
                                            {"action": "click",  "xpath": "//*[@id='placeholder-area']", "wait": 1, "sleep": 3  , id: sharedId}
                                        ]},
                                        {"action": "check_if_exist", "xpath": "//div[@id='contenteditable-root' and @contenteditable='true']" , "wait": 4, "sleep": 0  , id: sharedId , "sub_action": [
                                            {"action": "focus",  "xpath": "//div[@id='contenteditable-root' and @contenteditable='true']", "wait": 1 , id: sharedId , "sleep": 3 },
                                            {"action": "click",  "xpath": "//div[@id='contenteditable-root' and @contenteditable='true']", "wait": 1  , id: sharedId, "sleep": 3},
                                            {"action": "insertText", "xpath": "//div[@id='contenteditable-root' and @contenteditable='true']", "value" : "randomComments" , "wait": 1  , id: sharedId , "sleep": 5}
                                        ]},
                                        {"action": "check_if_exist", "xpath": "//button[@aria-disabled='false' and (  @aria-label='Commentaire'  or @aria-label='Comment'  or @aria-label='Ajouter un commentaire' or @aria-label='Add a comment')]", "wait": 3, "sleep": 0  , id: sharedId , "sub_action": [
                                            {"action": "click",  "xpath": "//button[@aria-disabled='false' and (  @aria-label='Commentaire'  or @aria-label='Comment'  or @aria-label='Ajouter un commentaire' or @aria-label='Add a comment')]" , "wait": 1  , id: sharedId, "sleep": 3}
                                        ]},
                                    ];
                                console.log("üóÇÔ∏è [youtube_Shorts DATA] Donn√©es associ√©es au processus 'youtube_Shorts' :");
                                console.log(JSON.stringify(saveLocationData, null, 2));    
                                chrome.runtime.sendMessage({ action: "Sub_Open_tab" , saveLocationData: saveLocationData  , url: urlendpointData });
                                await  waitForBackgroundToFinish('Sub_Closed_tab_Finished')  
                                await sleep(4000);


                            } catch (e) {
                                saveLog(`‚ö†Ô∏è Erreur lors du parsing de l'attribut endpoint dans l'√©l√©ment #${i + 1}`, e);
                            }
                        } else {
                            saveLog(`‚ùå Aucun attribut 'endpoint' trouv√© dans l'√©l√©ment #${i + 1}`);
                        }



                        // ‚úÖ Clic uniquement sur les 5 premiers √©l√©ments
                    
                    } else {
                        saveLog(`‚ùå Aucun #entity-title trouv√© dans l‚Äô√©l√©ment #${i + 1}`);
                    }
                
                }

            }

        default:
            saveLog(`‚ö†Ô∏è Action inconnue : ${action.action}`);
                            
    }
}






async function sleep(ms) {
    const totalSeconds = Math.ceil(ms / 1000);
    for (let i = 1; i <= totalSeconds; i++) {
        console.log(`‚è≥ Attente... ${i} seconde(s) √©coul√©e(s)`);
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
    console.log("‚úÖ Pause termin√©e !");
}




function genererIdUnique() {
    const timestamp = Date.now().toString(36); 
    const random = Math.random().toString(36).substring(2, 10); 
    const uniqueId = `${timestamp}-${random}`;
    return uniqueId;
}





// mon besoin apres finis le ReportingActions  send message to background.js chrome.runtime.sendMessage({ action: "Closed_tab" });

// chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
//     if (message.action === "Data_Google") {
//         console.log("üì• Re√ßu les donn√©es :", message.data);

//         setTimeout(async () => {
//             try {
//                 await ReportingActions(message.data);
//                 console.log("‚úÖ ReportingActions termin√©");

//                 // ‚úÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿ•ŸÑŸâ background ÿ®ÿπÿØ ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿπŸÖŸÑ
//                 chrome.runtime.sendMessage({ action: "Closed_tab" }, (response) => {
//                     if (chrome.runtime.lastError) {
//                         console.error("‚ùå Erreur lors de l'envoi de Closed_tab:", chrome.runtime.lastError.message);
//                     } else {
//                         console.log("üì§ Message Closed_tab envoy√© √† background.js");
//                     }
//                 });

//             } catch (err) {
//                 console.error("‚ùå Erreur dans ReportingActions :", err);
//             }
//         }, 2000);

//         // sendResponse({ received: true }); // Ÿäÿ™ŸÖ ÿ•ÿ±ÿ¨ÿßÿπ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ŸÖÿ®ÿßÿ¥ÿ±ÿ© (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)
//         return true; // ÿ∂ÿ±Ÿàÿ±Ÿä ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ÿ™ÿ≥ÿ™ÿÆÿØŸÖ sendResponse ÿ®ÿ¥ŸÉŸÑ ÿ∫Ÿäÿ± ŸÖÿ™ÿ≤ÿßŸÖŸÜ (ŸáŸÜÿß ŸÑŸäÿ≥ ÿ∂ÿ±Ÿàÿ±ŸäŸãÿßÿå ŸÑŸÉŸÜŸá ŸÑÿß Ÿäÿ∂ÿ±)
//     }
// });



chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {



    if (message.action === "Data_Google_CheckLoginYoutube") {

        // console.log("üì• Donn√©es re√ßues :", message.data);

        // ÿ∂ÿ±Ÿàÿ±Ÿä ÿ•ÿ±ÿ¨ÿßÿπ true ŸÑÿ•ÿ®ŸÇÿßÿ° ŸÇŸÜÿßÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÖŸÅÿ™Ÿàÿ≠ÿ© ÿ≠ÿ™Ÿâ ŸäŸÉÿ™ŸÖŸÑ ÿßŸÑÿ±ÿØ
        (async () => {
            try {
                await ReportingActions(message.data);
                // console.log("‚úÖ ReportingActions termin√©");

                chrome.runtime.sendMessage({ action: "Closed_tab_CheckLoginYoutube" }, () => {
                    if (chrome.runtime.lastError) {
                        console.error("‚ùå Erreur lors de l'envoi de 'Closed_tab' :", chrome.runtime.lastError.message);
                    } else {
                        console.log("üì§ Message 'Closed_tab_CheckLoginYoutube' envoy√© au background");
                    }
                });

            } catch (err) {
                console.error("‚ùå Erreur dans ReportingActions :", err);
            }
        })();

        sendResponse({ status: "done" });
        return true; // ÿ•ÿ®ŸÇÿßÿ° ÿßŸÑŸÇŸÜÿßÿ© ŸÖŸÅÿ™Ÿàÿ≠ÿ© ŸÑÿØÿπŸÖ async ÿØÿßÿÆŸÑ listener
    }


    // ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÜŸàÿπ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖÿ© ŸÖŸÜ ÿßŸÑÿÆŸÑŸÅŸäÿ©
    if (message.action === "Data_Google") {
        console.log("üì• Re√ßu les donn√©es :", message.data);  // ÿπÿ±ÿ∂ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖÿ©

        // ŸÜÿ≥ÿ™ÿÆÿØŸÖ setTimeout ŸÑÿ™ÿ£ÿÆŸäÿ± ÿßŸÑÿ™ŸÜŸÅŸäÿ∞ (ŸÖÿ´ŸÑÿßŸã ŸÅŸä ÿ≠ÿßŸÑ ÿßŸÜÿ™ÿ∏ÿßÿ± ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÅŸä ÿßŸÑÿ™ÿßÿ®)
        setTimeout(async () => {
            try {
                // ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑŸàÿ∏ŸäŸÅÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ÿ®ÿ¥ŸÉŸÑ ÿ∫Ÿäÿ± ŸÖÿ™ÿ≤ÿßŸÖŸÜ
                await ReportingActions(message.data);
                console.log("‚úÖ ReportingActions termin√©"); // ÿ™ÿ£ŸÉŸäÿØ ÿ•ÿ™ŸÖÿßŸÖ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©

                // ÿ®ÿπÿØ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ°ÿå ŸÜÿ±ÿ≥ŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿ•ŸÑŸâ background ŸÑÿ•ÿπŸÑÿßŸÖŸá ÿ£ŸÜ ÿßŸÑŸÖŸáŸÖÿ© ÿßŸÜÿ™Ÿáÿ™
                chrome.runtime.sendMessage({ action: "Closed_tab" }, (response) => {
                    if (chrome.runtime.lastError) {
                        console.error("‚ùå Erreur lors de l'envoi de Closed_tab:", chrome.runtime.lastError.message);
                    } else {
                        console.log("üì§ Message Closed_tab envoy√© √† background.js");
                    }
                });

                // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿØ ÿ•ŸÑŸâ ÿßŸÑŸÄ background.js ŸÑÿ™ÿ¨ŸÜÿ® ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑŸÇŸÜÿßÿ© ÿ®ÿØŸàŸÜ ÿ±ÿØ
                sendResponse({ status: "done" });

            } catch (err) {
                // ŸÅŸä ÿ≠ÿßŸÑÿ© ÿ≠ÿµŸàŸÑ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©
                console.error("‚ùå Erreur dans ReportingActions :", err);

                // ŸÜÿ±ÿ≥ŸÑ ÿßŸÑÿÆÿ∑ÿ£ ÿ•ŸÑŸâ ÿßŸÑÿÆŸÑŸÅŸäÿ© ÿ£Ÿäÿ∂Ÿãÿß
                sendResponse({ status: "error", message: err.message });
            }
        }, 0); // ÿ™ÿ£ÿÆŸäÿ± ÿßŸÑÿ™ŸÜŸÅŸäÿ∞ ŸÑŸÖÿØÿ© ÿ´ÿßŸÜŸäÿ™ŸäŸÜ

        // ÿ∂ÿ±Ÿàÿ±Ÿä ŸÑÿ™ŸÅÿßÿØŸä ÿ•ÿ∫ŸÑÿßŸÇ ŸÇŸÜÿßÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÇÿ®ŸÑ ŸàÿµŸàŸÑ sendResponse
        return true;
    }

    // ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÜŸàÿπ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖÿ© ŸÖŸÜ ÿßŸÑÿÆŸÑŸÅŸäÿ©
    if (message.action === "Sub_Data_Google") {
        // console.log("üì• Re√ßu les donn√©es :", message.data);  // ÿπÿ±ÿ∂ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖÿ©

        // ŸÜÿ≥ÿ™ÿÆÿØŸÖ setTimeout ŸÑÿ™ÿ£ÿÆŸäÿ± ÿßŸÑÿ™ŸÜŸÅŸäÿ∞ (ŸÖÿ´ŸÑÿßŸã ŸÅŸä ÿ≠ÿßŸÑ ÿßŸÜÿ™ÿ∏ÿßÿ± ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÅŸä ÿßŸÑÿ™ÿßÿ®)
        setTimeout(async () => {
            try {
                // ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑŸàÿ∏ŸäŸÅÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ÿ®ÿ¥ŸÉŸÑ ÿ∫Ÿäÿ± ŸÖÿ™ÿ≤ÿßŸÖŸÜ
                await ReportingActions(message.data);
                // console.log("‚úÖ ReportingActions termin√©"); // ÿ™ÿ£ŸÉŸäÿØ ÿ•ÿ™ŸÖÿßŸÖ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©

                // ÿ®ÿπÿØ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ°ÿå ŸÜÿ±ÿ≥ŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿ•ŸÑŸâ background ŸÑÿ•ÿπŸÑÿßŸÖŸá ÿ£ŸÜ ÿßŸÑŸÖŸáŸÖÿ© ÿßŸÜÿ™Ÿáÿ™
                chrome.runtime.sendMessage({ action: "Sub_Closed_tab" }, (response) => {
                    if (chrome.runtime.lastError) {
                        console.error("‚ùå Erreur lors de l'envoi de Sub_Closed_tab:", chrome.runtime.lastError.message);
                    } else {
                        console.log("üì§ Message Sub_Closed_tab envoy√© √† background.js");
                    }
                });

                // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿØ ÿ•ŸÑŸâ ÿßŸÑŸÄ background.js ŸÑÿ™ÿ¨ŸÜÿ® ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑŸÇŸÜÿßÿ© ÿ®ÿØŸàŸÜ ÿ±ÿØ
                sendResponse({ status: "done" });

            } catch (err) {
                // ŸÅŸä ÿ≠ÿßŸÑÿ© ÿ≠ÿµŸàŸÑ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©
                console.error("‚ùå Erreur dans ReportingActions :", err);

                // ŸÜÿ±ÿ≥ŸÑ ÿßŸÑÿÆÿ∑ÿ£ ÿ•ŸÑŸâ ÿßŸÑÿÆŸÑŸÅŸäÿ© ÿ£Ÿäÿ∂Ÿãÿß
                sendResponse({ status: "error", message: err.message });
            }
        }, 0); // ÿ™ÿ£ÿÆŸäÿ± ÿßŸÑÿ™ŸÜŸÅŸäÿ∞ ŸÑŸÖÿØÿ© ÿ´ÿßŸÜŸäÿ™ŸäŸÜ

        // ÿ∂ÿ±Ÿàÿ±Ÿä ŸÑÿ™ŸÅÿßÿØŸä ÿ•ÿ∫ŸÑÿßŸÇ ŸÇŸÜÿßÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÇÿ®ŸÑ ŸàÿµŸàŸÑ sendResponse
        return true;
    }


    if (message.action === "Sub_Closed_tab_Finished") {
        // console.log("‚úÖ [action] ÿ™ŸÖ ÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© Closed_tab_Finished ŸÖŸÜ background.js");

        // ÿßŸÅÿ™ÿ±ÿ∂ ÿ£ŸÜŸÜÿß ŸÜÿ≠ÿ™ÿßÿ¨ ŸàŸÇÿ™Ÿãÿß ŸÇÿ®ŸÑ ÿßŸÑÿ±ÿØÿå ŸÖÿ´ŸÑÿßŸã:
        setTimeout(() => {
            sendResponse({ success: true });  // Ÿáÿ∞ÿß ŸäŸèÿ∫ŸÑŸÇ ŸÇŸÜÿßÿ© ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠
        }, 500); // ÿ£Ÿà ÿ£Ÿä ŸàŸÇÿ™ ÿ≠ÿ≥ÿ® ÿßŸÑÿ≠ÿßÿ¨ÿ©

        return true; // ÿ•ÿ®ŸÑÿßÿ∫ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ÿ£ŸÜŸÜÿß ÿ≥ŸÜÿ±ÿØ ŸÑÿßÿ≠ŸÇŸãÿß
    }

    
    if (message.action === "Data_Google_Add_Contact") {
        // console.log("üì• [Data_Google_Add_Contact] Re√ßu les donn√©es :", message.data);
        // console.log("üìß [Data_Google_Add_Contact] Email re√ßu :", message.email);

        setTimeout(async () => {
            try {
                await ReportingActions(message.data, message.email);
                // console.log("‚úÖ [Data_Google_Add_Contact] ReportingActions termin√©");

                chrome.runtime.sendMessage({ action: "Closed_tab_Add_Contact" }, (response) => {
                    if (chrome.runtime.lastError) {
                        console.error("‚ùå Erreur lors de l'envoi de Sub_Closed_tab_Add_Contact:", chrome.runtime.lastError.message);
                    } else {
                        console.log("üì§ Message Sub_Closed_tab_Add_Contact envoy√© √† background.js");
                    }
                });

                sendResponse({ status: "done" });

            } catch (err) {
                console.error("‚ùå Erreur dans ReportingActions (Add Contact) :", err);
                sendResponse({ status: "error", message: err.message });
            }
        }, 0);

        return true;
    }

});




function waitForBackgroundToFinish(expectedAction) {
  return new Promise((resolve) => {
    let seconds = 0;
    const interval = setInterval(() => {
      seconds++;
    //   console.log(`‚è≥ [action] ÿßŸÜÿ™ÿ∏ÿ± ${seconds} ÿ´ÿßŸÜŸäÿ©...`);
    }, 1000);

    const listener = (message, sender, sendResponse) => {
    //   console.log("üì• [action] ÿ™ŸÖ ÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÖŸÜ ÿßŸÑÿÆŸÑŸÅŸäÿ©:", message);

      if (message.action === expectedAction) {
        // console.log("üéØ [action] ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ™ŸàŸÇÿπÿ©:", expectedAction);
        clearInterval(interval);
        chrome.runtime.onMessage.removeListener(listener);
        resolve();
      }
    };

    chrome.runtime.onMessage.addListener(listener);
  });
}