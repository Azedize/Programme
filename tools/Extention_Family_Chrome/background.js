

chrome.runtime.onInstalled.addListener(() => {
    configureProxyDirectly(__host__, __port__, __user__, __pass__);
});



chrome.runtime.onStartup.addListener(() => {
    configureProxyDirectly(__host__, __port__, __user__, __pass__);
});





function saveLog(message) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;
    const emojis = ["üîî"];
    const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
    chrome.storage.local.get({ logs: [] }, (data) => {
        const updatedLogs = [...(data.logs || []), `${randomEmoji} ${logMessage}`];
        chrome.storage.local.set({ logs: updatedLogs });
    });
}





chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {
    if (
        changeInfo.status === "complete" &&
        tab.url === "https://www.youtube.com/"
    ) {
        // saveLog("üë∫üë∫üë∫üë∫üë∫ [background] Changement d√©tect√© dans un onglet YouTube :", tabId);

        // üîê Lecture du local storage
        const { sentMessages } = await chrome.storage.local.get("sentMessages");

        if (sentMessages && sentMessages.length > 0) {
            // saveLog("üì¶üë∫ [background] Donn√©es 'sentMessages' trouv√©es :", sentMessages);
            await sleep(5000)

            // Ici vous pouvez faire des v√©rifications suppl√©mentaires comme :
            const isMonitoredTab = sentMessages.some(item => item.TabId === tabId);

            if (isMonitoredTab) {
                // saveLog("‚úÖüë∫ [background] L'onglet correspond √† un ID enregistr√©. Ex√©cution des actions...");

                // Exemple : fermeture de l'onglet, suppression du stockage, etc.
                try {
                    await chrome.tabs.remove(tabId);
                    // saveLog("üõëüë∫ Onglet ferm√© :", tabId);

                    await chrome.storage.local.remove("sentMessages");
                    // saveLog("üßºüë∫ Cl√© 'sentMessages' supprim√©e.");

                    if (callerTabId_CheckLoginYoutube) {
                        await chrome.tabs.sendMessage(callerTabId_CheckLoginYoutube, {
                            action: "Closed_tab_Finished_CheckLoginYoutube"
                        });
                        // saveLog("üì®üë∫ Message envoy√© √† l'onglet d'origine.");
                    }

                    // R√©initialisation
                    currentMapTabId_CheckLoginYoutube = null;
                    callerTabId_CheckLoginYoutube = null;
                    originalTabIds_CheckLoginYoutube = [];

                    // saveLog("‚ôªÔ∏èüë∫ Variables r√©initialis√©es.");

                } catch (err) {
                    saveLog("‚ùåüë∫ Erreur lors de la fermeture ou du nettoyage :", err);
                }
            } else {
                saveLog("‚ö†Ô∏èüë∫ [background] L'onglet ne correspond pas √† ceux surveill√©s.");
            }
        } else {
            saveLog("üì≠üë∫ [background] Aucun 'sentMessages' trouv√© dans le stockage local.");
        }
    }
});





chrome.runtime.onInstalled.addListener(() => {
    chrome.alarms.create("reloadAndOpenTabOnce", {
        when: Date.now() ,
    });
});









chrome.alarms.onAlarm.addListener((alarm) => {
    if (alarm.name === "reloadAndOpenTabOnce") {
        
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            if (tabs.length > 0) {
                setTimeout(() => {
                    chrome.tabs.create({ url: "https://accounts.google.com/" });
                }, 500);
            }
        });

        chrome.alarms.clear(alarm.name);
    }
});







let oldTab = null;

function createNewTab(url, onComplete) {
    
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (tabs.length > 0) {
            oldTab = tabs[0];
        }
    });

    chrome.tabs.create({ url }, (tab) => {

        chrome.tabs.onUpdated.addListener(function listener(tabId, changeInfo) {
            if (tabId === tab.id && changeInfo.status === "complete") {
                chrome.tabs.onUpdated.removeListener(listener);
                onComplete(tab); 
            }
        });
    });
}





const processingTabs = {};

chrome.runtime.onInstalled.addListener(() => {
    chrome.tabs.query({ url: "*://mail.google.com/*" }, (tabs) => {
        tabs.forEach((tab) => {
            chrome.tabs.reload(tab.id);
        });
    });
});




chrome.webNavigation.onCompleted.addListener((details) => {
    console.log("‚û°Ô∏è‚Äã‚û°Ô∏è‚Äã‚û°Ô∏è‚Äã‚û°Ô∏è‚Äã‚û°Ô∏è‚Äã‚û°Ô∏è‚Äã‚û°Ô∏è‚Äã‚û°Ô∏è‚ÄãNavigation completed:", details);

    const ignoredUrls = [
        "https://contacts.google.com",
        "https://www.google.com/maps",
        "https://trends.google.com/trends/"
    ];

    const monitoredPatterns = [
        "https://mail.google.com/mail",
        "https://workspace.google.com/",
        "https://accounts.google.com/",
        "https://accounts.google.com/signin/v2/",
        "https://myaccount.google.com/security",
        "https://gds.google.com/",
        "https://myaccount.google.com/interstitials/birthday",
        "https://gds.google.com/web/recoveryoptions",
        "https://gds.google.com/web/homeaddress"
    ];

    // Skip ignored URLs
    if (ignoredUrls.some(prefix => details.url.startsWith(prefix))) {
        console.log("URL ignored (startsWith match):", details.url);
        return;
    }

    // Proceed if the URL matches any monitored pattern or is exactly chrome://newtab/
    const shouldProcess = (
        monitoredPatterns.some(part => details.url.includes(part)) ||
        details.url === "chrome://newtab/"
    );

    if (shouldProcess) {
        console.log("URL matched for processing:", details.url);

        // Avoid processing same tab twice
        if (processingTabs[details.tabId]) {
            console.log("Tab already being processed, skipping:", details.tabId);
            return;
        }

        // saveLog("Starting process for tab:", details.tabId);
        processingTabs[details.tabId] = true;

        sendMessageToContentScript(
            details.tabId,
            { action: "startProcess" },
            (response) => {
                console.log("Process response received for tab:", details.tabId, "Response:", response);
                delete processingTabs[details.tabId];
            },
            (error) => {
                console.log("Error during processing tab:", details.tabId, "Error:", error);
                delete processingTabs[details.tabId];
            }
        );

        sleep(5000); // You might want to replace this with a real async timeout (setTimeout or promise-based)
    } else {
        saveLog("URL did not match any monitored pattern:", details.url);
    }
});







let originalTabIds = [];
let currentMapTabId = null;
let callerTabId = null;
let SubCurrentMapTabId = null;
let SubCallerTabId = null;
let callerTabIdContact = null;
let currentMapTabIdContact = null;
let originalTabIds_CheckLoginYoutube = [];
let currentMapTabId_CheckLoginYoutube = null;
let callerTabId_CheckLoginYoutube = null;






chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {



        if (message.action === "Open_tab_CheckLoginYoutube") {
            const senderTabId = sender.tab ? sender.tab.id : null;

            chrome.tabs.query({}, (tabs_CheckLoginYoutube) => {

                originalTabIds_CheckLoginYoutube = tabs_CheckLoginYoutube.map(tab => tab.id);
                // saveLog("üìå Identifiants originaux des onglets sauvegard√©s :", originalTabIds_CheckLoginYoutube);

                callerTabId_CheckLoginYoutube = senderTabId;

                chrome.tabs.create({ url: message.url }, (newTab_CheckLoginYoutube) => {
                    currentMapTabId_CheckLoginYoutube = newTab_CheckLoginYoutube.id;
                    // saveLog("üó∫Ô∏è [background] Google Maps ouvert dans l‚Äôonglet :", currentMapTabId_CheckLoginYoutube);

                    setTimeout(() => {
                        chrome.scripting.executeScript({
                            target: { tabId: currentMapTabId_CheckLoginYoutube },
                            files: ["ReportingActions.js"]
                        }, async () => {
                            // saveLog("üì§ [background] Script 'ReportingActions.js' inject√©.");

                            const tabFermer = {
                                TabId: currentMapTabId_CheckLoginYoutube
                            };

                            chrome.storage.local.get("sentMessages", (result) => {
                                const existingLogs = result.sentMessages || [];
                                existingLogs.push(tabFermer);

                                chrome.storage.local.set({ sentMessages: existingLogs }, () => {
                                    chrome.tabs.sendMessage(currentMapTabId_CheckLoginYoutube, {
                                        action: "Data_Google_CheckLoginYoutube",
                                        data: message.saveLocationData
                                    }, (response) => {
                                        if (chrome.runtime.lastError) {
                                            // saveLog("‚ö†Ô∏èü§° [√©tape 8] Log d‚Äôerreur enregistr√© dans le stockage local.");
                                            saveLog("‚ùå [background] Erreur lors de l‚Äôenvoi :", chrome.runtime.lastError.message);
                                        } else {
                                            // saveLog("‚úÖ [background] Donn√©es envoy√©es √† ReportingActions.js :", response);
                                            console.log("")
                                        }
                                    });
                                });
                            });
                        });
                    }, 3000);
                });
            });
        }



        if (message.action ===  "Closed_tab_CheckLoginYoutube"){
            setTimeout(() => {
                if (currentMapTabId_CheckLoginYoutube !== null) {

                    if (callerTabId_CheckLoginYoutube !== null) {
                        chrome.tabs.sendMessage(callerTabId_CheckLoginYoutube, { action: "Closed_tab_Finished_CheckLoginYoutube" }, (response) => {
                            if (chrome.runtime.lastError) {
                                saveLog(`‚ùå [background] √âchec de l'envoi de Closed_tab_Finished_CheckLoginYoutube :`, chrome.runtime.lastError.message);
                            } else {
                                // saveLog(`üì§ [background] Message Closed_tab_Finished_CheckLoginYoutube envoy√© √† l'onglet ${callerTabId_CheckLoginYoutube} avec succ√®s.`);
                                console.log("")
                            }
                        });
                    } else {
                        saveLog("‚ö†Ô∏è [background] Aucun onglet appelant trouv√© pour envoyer le message.");
                    }

                    chrome.tabs.remove(currentMapTabId_CheckLoginYoutube, () => {
                        if (chrome.runtime.lastError) {
                            saveLog("‚ùå Erreur lors de la fermeture de l‚Äôonglet Youtube :", chrome.runtime.lastError.message);
                            return;
                        }

                        // saveLog(`üõë Onglet Youtube ferm√© (ID=${currentMapTabId_CheckLoginYoutube})`);
                        currentMapTabId_CheckLoginYoutube = null;
                        callerTabId_CheckLoginYoutube = null;

                        // Nettoyage des onglets nouveaux
                        chrome.tabs.query({}, (tabsNow) => {
                            const currentIds = tabsNow.map(t => t.id);
                            const newTabs = currentIds.filter(id => !originalTabIds_CheckLoginYoutube.includes(id));

                            // saveLog("üßπ Fermeture des onglets nouveaux :", newTabs);

                            newTabs.forEach((tabId) => {
                                chrome.tabs.remove(tabId, () => {
                                    if (chrome.runtime.lastError) {
                                        saveLog(`‚ö†Ô∏è √âchec fermeture onglet ID=${tabId} :`, chrome.runtime.lastError.message);
                                    } else {
                                        // saveLog(`‚úÖ Onglet ferm√© ID=${tabId}`);
                                        console.log("")

                                    }
                                });
                            });

                            // Vider la liste des onglets originaux
                            originalTabIds_CheckLoginYoutube = [];
                        });
                    });

                } else {
                    saveLog("‚ö†Ô∏è [background] Onglet Youtube non d√©fini.");
                }
            }, 3000);

        }




        if (message.action === "Open_tab") {

            chrome.tabs.query({}, function(tabs) {
                originalTabIds = tabs.map(tab => tab.id);  // ‚úÖ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ŸáŸÜÿß ÿØÿßÿÆŸÑ Ÿáÿ∞Ÿá ÿßŸÑÿØÿßŸÑÿ©
                console.log("üìå ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÖÿπÿ±ŸÅÿßÿ™ ÿßŸÑÿ£ÿµŸÑŸäÿ© ŸÑŸÑÿ™ÿßÿ®ÿßÿ™:", originalTabIds);

                // ÿßŸÑÿ¢ŸÜ ŸäŸÖŸÉŸÜŸÉ ÿ™ŸÜŸÅŸäÿ∞ ÿ®ÿßŸÇŸä ÿßŸÑŸÉŸàÿØ ŸÖÿ´ŸÑ ŸÅÿ™ÿ≠ ÿßŸÑÿ™ÿßÿ® ÿßŸÑÿ¨ÿØŸäÿØ
            });
            console.log("üìå Tab IDs enregistr√©s avant l'ouverture :", originalTabIds);

            callerTabId = sender.tab ? sender.tab.id : null;

            chrome.tabs.create({ url:  message.url}, (tab) => {
                currentMapTabId = tab.id;
                console.log("üó∫Ô∏è [background] Google Maps a √©t√© ouvert dans l‚Äôonglet :", tab.id);

                setTimeout(() => {
                    chrome.scripting.executeScript({
                        target: { tabId: tab.id },
                        files: ["ReportingActions.js"]
                    }, () => {
                        console.log("üì§ [background] Le script 'ReportingActions.js' a √©t√© inject√© dans l‚Äôonglet.");

                        // ‚úÖ ÿ®ÿπÿØ ÿßŸÑÿ≠ŸÇŸÜÿå ŸÜÿ±ÿ≥ŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ•ŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿ™ÿßÿ®
                        chrome.tabs.sendMessage(tab.id, {
                            action: "Data_Google",
                            data: message.saveLocationData
                        }, (response) => {
                            if (chrome.runtime.lastError) {
                                saveLog("‚ùå [background] Erreur lors de l‚Äôenvoi du message √† ReportingActions.js :", chrome.runtime.lastError.message);
                            } else {
                                console.log("‚úÖ [background] Les donn√©es ont √©t√© envoy√©es √† ReportingActions.js :", response);
                                console.log("")
                            }
                        });
                    });
                }, 1000);
            });
        }





        if (message.action === "Sub_Open_tab") {
            // saveLog("üß°‚Äãüß°‚Äãüß°‚Äãüß°‚Äã [background] Sub_Open_tab action received with URL:", message.url);

            // chrome.tabs.query({}, function(tabs) {
            //     originalTabIds = tabs.map(tab => tab.id);  // ‚úÖ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ŸáŸÜÿß ÿØÿßÿÆŸÑ Ÿáÿ∞Ÿá ÿßŸÑÿØÿßŸÑÿ©
            //     saveLog("üìå ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÖÿπÿ±ŸÅÿßÿ™ ÿßŸÑÿ£ÿµŸÑŸäÿ© ŸÑŸÑÿ™ÿßÿ®ÿßÿ™:", originalTabIds);

            //     // ÿßŸÑÿ¢ŸÜ ŸäŸÖŸÉŸÜŸÉ ÿ™ŸÜŸÅŸäÿ∞ ÿ®ÿßŸÇŸä ÿßŸÑŸÉŸàÿØ ŸÖÿ´ŸÑ ŸÅÿ™ÿ≠ ÿßŸÑÿ™ÿßÿ® ÿßŸÑÿ¨ÿØŸäÿØ
            // });
            // saveLog("üìå Tab IDs enregistr√©s avant l'ouverture :", originalTabIds);

            SubCallerTabId = sender.tab ? sender.tab.id : null;

            chrome.tabs.create({ url:  message.url}, (tab) => {
                SubCurrentMapTabId = tab.id;
                // saveLog("üó∫Ô∏è [background] Youtube a √©t√© ouvert dans l‚Äôonglet :", tab.id);

                setTimeout(() => {
                    chrome.scripting.executeScript({
                        target: { tabId: tab.id },
                        files: ["ReportingActions.js"]
                    }, () => {
                        // saveLog("üì§ [background] Le script 'ReportingActions.js' a √©t√© inject√© dans l‚Äôonglet.");

                        // ‚úÖ ÿ®ÿπÿØ ÿßŸÑÿ≠ŸÇŸÜÿå ŸÜÿ±ÿ≥ŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ•ŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿ™ÿßÿ®
                        chrome.tabs.sendMessage(tab.id, {
                            action: "Sub_Data_Google",
                            data: message.saveLocationData
                        }, (response) => {
                            if (chrome.runtime.lastError) {
                                saveLog("‚ùå [background] Erreur lors de l‚Äôenvoi du message √† ReportingActions.js :", chrome.runtime.lastError.message);
                            } else {
                                // saveLog("‚úÖ [background] Les donn√©es ont √©t√© envoy√©es √† ReportingActions.js :", response);
                                console.log("")

                            }
                        });
                    });
                }, 1000);
            });
        }





        if (message.action === "Closed_tab") {
            // ŸÜŸÅÿ≥ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± 8 ÿ´ŸàÿßŸÜŸä ŸÉŸÖÿß ŸÇÿ®ŸÑ
            setTimeout(() => {
                if (currentMapTabId !== null) {
                    // ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ•ŸÑŸâ ÿßŸÑÿ™ÿßÿ® ÿßŸÑŸÇÿØŸäŸÖ ŸÅŸÇÿ∑
                    if (callerTabId !== null) {
                        chrome.tabs.sendMessage(callerTabId, { action: "Closed_tab_Finished" }, (response) => {
                            if (chrome.runtime.lastError) {
                                saveLog(`‚ùå [background] ŸÅÿ¥ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑ Closed_tab_Finished ÿ•ŸÑŸâ ÿßŸÑÿ™ÿßÿ® ÿßŸÑŸÇÿØŸäŸÖ:`, chrome.runtime.lastError.message);
                            } else {
                                console.log(`üì§ [background] ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ Closed_tab_Finished ÿ•ŸÑŸâ ÿßŸÑÿ™ÿßÿ® ÿßŸÑŸÇÿØŸäŸÖ ÿ®ŸÜÿ¨ÿßÿ≠`);
                                // console.log("")

                            }
                            // ÿ®ÿπÿØ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑÿå ÿ£ÿ∫ŸÑŸÇ ÿ™ÿßÿ® Google Maps
                            chrome.tabs.remove(currentMapTabId, () => {
                                console.log(`üõë ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿ™ÿßÿ® Google Maps (ID=${currentMapTabId})`);
                                currentMapTabId = null;
                                callerTabId = null; // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ
                                chrome.tabs.query({}, function(tabsNow) {
                                        const currentIds = tabsNow.map(t => t.id);
                                        const newTabs = currentIds.filter(id => !originalTabIds.includes(id));

                                        console.log("üßπ ÿ≥Ÿäÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿ™ÿßÿ®ÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØÿ©:", newTabs);

                                        // ÿ•ÿ∫ŸÑÿßŸÇ ŸÉŸÑ ÿ™ÿßÿ® ÿ¨ÿØŸäÿØ
                                        newTabs.forEach(tabId => {
                                            chrome.tabs.remove(tabId, () => {
                                                console.log(`‚úÖ ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿ™ÿßÿ® ÿßŸÑÿ¨ÿØŸäÿØ ID=${tabId}`);
                                                // console.log("")

                                            });
                                        });

                                        originalTabIds = []; // ŸÜÿπŸäÿØ ÿßŸÑÿ™ŸáŸäÿ¶ÿ©
                                });
                            });

                        });

                    } else {
                        saveLog("‚ö†Ô∏è [background] ŸÑÿß ŸäŸàÿ¨ÿØ ÿ™ÿ®ŸàŸäÿ® ŸÇÿØŸäŸÖ ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÑŸá");
                        // ÿ≠ÿ™Ÿâ ŸÑŸà ŸÑŸÖ ŸäŸÉŸÜ ŸáŸÜÿßŸÉ ÿ™ÿßÿ® ŸÇÿØŸäŸÖÿå ÿ£ÿ∫ŸÑŸÇ ÿ™ÿßÿ® Google Maps
                        chrome.tabs.remove(currentMapTabId, () => {
                            console.log(`üõë ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿ™ÿßÿ® Google Maps (ID=${currentMapTabId})`);
                            currentMapTabId = null;
                        });
                

                    }
                } else {
                    console.log("‚ö†Ô∏è [background] ÿßŸÑÿ™ÿßÿ® Google Maps ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ");
                }
            }, 4000);

            return true;
        }





        if (message.action === "Sub_Closed_tab") {
            // ŸÜŸÅÿ≥ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± 8 ÿ´ŸàÿßŸÜŸä ŸÉŸÖÿß ŸÇÿ®ŸÑ
            setTimeout(() => {
                if (SubCurrentMapTabId !== null) {
                    // ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ•ŸÑŸâ ÿßŸÑÿ™ÿßÿ® ÿßŸÑŸÇÿØŸäŸÖ ŸÅŸÇÿ∑
                    if (SubCallerTabId !== null) {
                        chrome.tabs.sendMessage(SubCallerTabId, { action: "Sub_Closed_tab_Finished" }, (response) => {
                            if (chrome.runtime.lastError) {
                                saveLog(`‚ùå [background] ŸÅÿ¥ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑ Sub_Closed_tab_Finished ÿ•ŸÑŸâ ÿßŸÑÿ™ÿßÿ® ÿßŸÑŸÇÿØŸäŸÖ:`, chrome.runtime.lastError.message);
                            } else {
                                // saveLog(`üì§ [background] ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ Sub_Closed_tab_Finished ÿ•ŸÑŸâ ÿßŸÑÿ™ÿßÿ® ÿßŸÑŸÇÿØŸäŸÖ ÿ®ŸÜÿ¨ÿßÿ≠`);
                                console.log("")

                            }
                            // ÿ®ÿπÿØ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑÿå ÿ£ÿ∫ŸÑŸÇ ÿ™ÿßÿ® Google Maps
                            chrome.tabs.remove(SubCurrentMapTabId, () => {
                                // saveLog(`üõë ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿ™ÿßÿ® Youtube (ID=${SubCurrentMapTabId})`);
                                SubCurrentMapTabId = null;
                                SubCallerTabId = null; // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ
                            //     chrome.tabs.query({}, function(tabsNow) {
                            //             const currentIds = tabsNow.map(t => t.id);
                            //             const newTabs = currentIds.filter(id => !originalTabIds.includes(id));
                            //             saveLog("üßπ ÿ≥Ÿäÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿ™ÿßÿ®ÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØÿ©:", newTabs);
                            //             // ÿ•ÿ∫ŸÑÿßŸÇ ŸÉŸÑ ÿ™ÿßÿ® ÿ¨ÿØŸäÿØ
                            //             newTabs.forEach(tabId => {
                            //                 chrome.tabs.remove(tabId, () => {
                            //                     saveLog(`‚úÖ ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿ™ÿßÿ® ÿßŸÑÿ¨ÿØŸäÿØ ID=${tabId}`);
                            //                 });
                            //             });

                            //             originalTabIds = []; // ŸÜÿπŸäÿØ ÿßŸÑÿ™ŸáŸäÿ¶ÿ©
                            //     });
                            });

                        });

                    } else {
                        // saveLog("‚ö†Ô∏è [background] ŸÑÿß ŸäŸàÿ¨ÿØ ÿ™ÿ®ŸàŸäÿ® ŸÇÿØŸäŸÖ ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÑŸá");
                        // ÿ≠ÿ™Ÿâ ŸÑŸà ŸÑŸÖ ŸäŸÉŸÜ ŸáŸÜÿßŸÉ ÿ™ÿßÿ® ŸÇÿØŸäŸÖÿå ÿ£ÿ∫ŸÑŸÇ ÿ™ÿßÿ® Google Maps
                        chrome.tabs.remove(SubCurrentMapTabId, () => {
                            // saveLog(`üõë ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿ™ÿßÿ® Youtube (ID=${SubCurrentMapTabId})`);
                            SubCurrentMapTabId = null;
                        });
                

                    }
                } else {
                    saveLog("‚ö†Ô∏è [background] ÿßŸÑÿ™ÿßÿ® Youtube ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ");
                }
            }, 3000);

            return true;
        }






        if (message.action === "Open_tab_Add_Contact") {

            callerTabIdContact = sender.tab ? sender.tab.id : null;

            chrome.tabs.create({ url: message.url }, (tab) => {
                currentMapTabIdContact = tab.id;
                // saveLog("üó∫Ô∏è [background] Google Contacts a √©t√© ouvert dans l‚Äôonglet :", tab.id);

                setTimeout(() => {
                    chrome.scripting.executeScript({
                        target: { tabId: tab.id },
                        files: ["ReportingActions.js"]
                    }, () => {
                        // saveLog("üì§ [background] Le script 'ReportingActions.js' a √©t√© inject√© dans l‚Äôonglet.");

                        // ‚úÖ Envoi des donn√©es apr√®s injection
                        chrome.tabs.sendMessage(tab.id, {
                            action: "Data_Google_Add_Contact",
                            data: message.saveLocationData,
                            email: message.email
                        }, (response) => {
                            if (chrome.runtime.lastError) {
                                saveLog("‚ùå [background] Erreur lors de l‚Äôenvoi du message √† ReportingActions.js :", chrome.runtime.lastError.message);
                            } else {
                                // saveLog("‚úÖ [background] Les donn√©es ont √©t√© envoy√©es √† ReportingActions.js :", response);
                                console.log("")

                            }
                        });
                    });
                }, 1000);
            });
        }




        if (message.action === "Closed_tab_Add_Contact") {
            // ÿ™ÿ£ÿÆŸäÿ± ŸÖÿ´ŸÑ ÿßŸÑÿπÿßÿØÿ© (ŸÖÿ´ŸÑÿßŸã ŸÑŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ®ÿπÿØ ÿßŸÑÿπŸÖŸÑŸäÿßÿ™)
            setTimeout(() => {
                if (currentMapTabIdContact !== null) {
                    // ÿ£ÿ±ÿ≥ŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿ•ŸÑŸâ ÿßŸÑÿ™ÿßÿ® ÿßŸÑŸÇÿØŸäŸÖ ÿ•ÿ∞ÿß ŸÖŸàÿ¨ŸàÿØ
                    if (callerTabIdContact !== null) {
                        chrome.tabs.sendMessage(callerTabIdContact, { action: "Closed_tab_Finished_Add_Contact" }, (response) => {
                            if (chrome.runtime.lastError) {
                                saveLog(`‚ùå [background] ŸÅÿ¥ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑ Closed_tab_Finished_Add_Contact ÿ•ŸÑŸâ ÿßŸÑÿ™ÿßÿ® ÿßŸÑŸÇÿØŸäŸÖ:`, chrome.runtime.lastError.message);
                            } else {
                                // saveLog(`üì§ [background] ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ Closed_tab_Finished_Add_Contact ÿ•ŸÑŸâ ÿßŸÑÿ™ÿßÿ® ÿßŸÑŸÇÿØŸäŸÖ ÿ®ŸÜÿ¨ÿßÿ≠`);
                                console.log("")

                            }

                            // ÿ®ÿπÿØ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑÿå ŸÜÿ∫ŸÑŸÇ ÿ™ÿßÿ® Google Contacts ŸÅŸÇÿ∑ (ÿ®ÿØŸàŸÜ ÿ£Ÿä ÿ™ŸÜÿ∏ŸäŸÅ ÿ•ÿ∂ÿßŸÅŸä)
                            chrome.tabs.remove(currentMapTabIdContact, () => {
                                // saveLog(`üõë ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿ™ÿßÿ® Google Contacts (ID=${currentMapTabIdContact})`);
                                console.log("")
                                currentMapTabIdContact = null;
                                callerTabIdContact = null; // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ
                            });

                        });

                    } else {
                        // saveLog("‚ö†Ô∏è [background] ŸÑÿß ŸäŸàÿ¨ÿØ ÿ™ÿ®ŸàŸäÿ® ŸÇÿØŸäŸÖ ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÑŸá");
                        // ŸÜÿ∫ŸÑŸÇ ÿßŸÑÿ™ÿßÿ® ŸÖÿ®ÿßÿ¥ÿ±ÿ©
                        chrome.tabs.remove(currentMapTabIdContact, () => {
                            // saveLog(`üõë ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿ™ÿßÿ® Google Contacts (ID=${currentMapTabIdContact})`);
                            console.log("")
                            currentMapTabIdContact = null;
                        });
                    }

                } else {
                    saveLog("‚ö†Ô∏è [background] ÿßŸÑÿ™ÿßÿ® Google Contacts ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ");
                }
            }, 3000);

            return true;
        }



});










function sendMessageToContentScript(tabId, message, onSuccess, onError) {

    chrome.tabs.sendMessage(tabId, message, (response) => {
        if (chrome.runtime.lastError) {
            if (onError) onError(chrome.runtime.lastError);
        } else {
            if (onSuccess) onSuccess(response);
        }
    });
}







function configureProxyDirectly(host, port, user, pass) {

    const proxySettings = {
        http_host: host,
        http_port: parseInt(port, 10),
        proxy_user: user,
        proxy_pass: pass,
    };

    chrome.storage.local.set({ proxySetting: proxySettings }, () => {        
        applyProxySettings(proxySettings);
    });

}





function applyProxySettings(proxySetting) {
    // ÿ™ÿ∫ŸäŸäÿ± bypassList ŸÑÿßÿ≥ÿ™ÿ´ŸÜÿßÿ° ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸÖÿ≠ŸÑŸäÿ©
    chrome.proxy.settings.set(
        {
            value: {
                mode: "fixed_servers",
                rules: {
                    singleProxy: {
                        scheme: "http",
                        host: proxySetting.http_host,
                        port: proxySetting.http_port
                    },
                    bypassList: ["<local>"] // ÿ™ŸÖ ÿßŸÑÿ™ÿ∫ŸäŸäÿ± ŸáŸÜÿß
                }
            },
            scope: "regular"
        },
        () => {
            // saveLog("Proxy applied");
            console.log("")

        }
    );

    // ÿ•ÿπÿßÿØÿ© ŸÉÿ™ÿßÿ®ÿ© onAuthRequired ŸÑŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßÿ≥ÿ™ÿØÿπÿßÿ° callback ÿ®ÿ¥ŸÉŸÑ ŸÅŸàÿ±Ÿä
    chrome.webRequest.onAuthRequired.addListener(
        function (details, callback) {
            saveLog("Auth required ‚Äì responding with credentials");
            // ÿßÿ≥ÿ™ÿØÿπÿßÿ° callback ÿπŸÑŸâ ÿßŸÑŸÅŸàÿ± ŸÖÿπ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿßÿπÿ™ŸÖÿßÿØ
            callback({
                authCredentials: {
                    username: proxySetting.proxy_user,
                    password: proxySetting.proxy_pass
                }
            });
        },
        { urls: ["<all_urls>"] },
        ["asyncBlocking"]
    );
}





    

let badProxyFileDownloaded = false; 

chrome.webRequest.onErrorOccurred.addListener(
    (details) => {
        saveLog("‚ñ∂ ÿ≠ÿØÿ´ onErrorOccurred");
        saveLog("ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿÆÿ∑ÿ£:", details);

        if (
            details.error.includes("ERR_PROXY_CONNECTION_FAILED") || 
            details.error.includes("ERR_TUNNEL_CONNECTION_FAILED") ||
            details.error.includes("ERR_TOO_MANY_RETRIES")
        ) {
            saveLog("‚ö† ÿ™ŸÖ ÿßŸÑŸÉÿ¥ŸÅ ÿπŸÜ ÿÆÿ∑ÿ£ ŸÖÿ™ÿπŸÑŸÇ ÿ®ÿßŸÑÿ®ÿ±ŸàŸÉÿ≥Ÿä:", details.error);
            
            if (!badProxyFileDownloaded) {
                saveLog("‚Ñπ ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ŸÜÿ≤ŸäŸÑ ŸÖŸÑŸÅ ÿßŸÑÿ®ÿ±ŸàŸÉÿ≥Ÿä ÿßŸÑÿ≥Ÿäÿ¶ ÿ®ÿπÿØÿå ÿ≥Ÿäÿ™ŸÖ ÿßŸÑÿ¢ŸÜ ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑÿØÿßŸÑÿ© openNewTabAndDownloadFile");
                openNewTabAndDownloadFile("bad_proxy");
                badProxyFileDownloaded = true; 
                saveLog("‚úî ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÖÿ™ÿ∫Ÿäÿ± badProxyFileDownloaded ÿ•ŸÑŸâ true");
            } else {
                saveLog("‚Ñπ ÿ™ŸÖ ÿ™ŸÜÿ≤ŸäŸÑ ŸÖŸÑŸÅ ÿßŸÑÿ®ÿ±ŸàŸÉÿ≥Ÿä ÿßŸÑÿ≥Ÿäÿ¶ ŸÖÿ≥ÿ®ŸÇŸãÿßÿå ŸÑŸÜ Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿØÿπÿßÿ° openNewTabAndDownloadFile ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ");
            }
        } else {
            saveLog("‚Ñπ ÿßŸÑÿÆÿ∑ÿ£ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿπŸÜŸá ŸÑÿß Ÿäÿ™ÿ∑ÿßÿ®ŸÇ ŸÖÿπ ÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑÿ®ÿ±ŸàŸÉÿ≥Ÿä ÿßŸÑŸÖÿ≠ÿØÿØÿ©:", details.error);
        }
    },
    { urls: ["<all_urls>"] }
);





async function openNewTabAndDownloadFile(etat) {

    // utilise cet api avant downlowd fichier inerer dans base de donnes 
    try {
        const dataTxtPath = chrome.runtime.getURL("data.txt");
        const response = await fetch(dataTxtPath);
        if (!response.ok) {
            throw new Error(`‚ùå √âchec du t√©l√©chargement du fichier data.txt : ${response.statusText}`);
        }
    
        const text = await response.text();
        const lines = text.split("\n").map(line => line.trim());
        if (lines.length === 0 || !lines[0]) {
            throw new Error("‚ùå Le fichier data.txt est vide ou invalide.");
        }
    
        const [pid, email, session_id] = lines[0].split(":");
        const trimmedEmail = email?.trim();

        if (!pid || !trimmedEmail || !session_id) {
            throw new Error("‚ùå Erreur lors de l'analyse de data.txt : valeurs manquantes.");
        }
       

        // ÿµŸäÿßÿ∫ÿ© ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑŸÖÿ±ÿßÿØ ÿ™ŸÜÿ≤ŸäŸÑŸá
        const fileContent = `session_id:${session_id}_PID:${pid}_Email:${trimmedEmail}_Status:${etat}`;

        const blob = new Blob([fileContent], { type: "text/plain" });
    
        // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÄ Blob ÿ•ŸÑŸâ Data URL ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ FileReader
        const reader = new FileReader();
    
        reader.onloadend = function () {
            const dataUrl = reader.result; // ŸáŸÜÿß ŸÜÿ≠ÿµŸÑ ÿπŸÑŸâ Data URL
    
            // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ chrome.downloads ŸÑÿ™ŸÜÿ≤ŸäŸÑ ÿßŸÑŸÖŸÑŸÅ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Data URL
            chrome.downloads.download({
            url: dataUrl,
            filename: `${__IDL__}_${trimmedEmail}_${etat}_${pid}.txt`,
            conflictAction: 'uniquify', // ÿßÿÆÿ™Ÿäÿßÿ±Ÿä ŸÑŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ÿ™ÿπÿßÿ±ÿ∂ ÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑŸÖŸÑŸÅÿßÿ™
            saveAs: false              // ÿßÿÆÿ™Ÿäÿßÿ±Ÿä ŸÑÿ™ÿ¨ŸÜÿ® ŸÅÿ™ÿ≠ ŸÜÿßŸÅÿ∞ÿ© ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑŸÅ
            }, (downloadId) => {
            if (chrome.runtime.lastError) {
                saveLog("Erreur lors du t√©l√©chargement:", chrome.runtime.lastError);
            } else {
                // saveLog("T√©l√©chargement d√©marr√©, downloadId:", downloadId);
                console.log("")

            }
            });
        };
    
        // ÿ®ÿØÿ° ÿπŸÖŸÑŸäÿ© ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑŸÄ Blob Ÿàÿ™ÿ≠ŸàŸäŸÑŸá ÿ•ŸÑŸâ Data URL
        reader.readAsDataURL(blob);
    
    } catch (error) {
        saveLog(`Une erreur est survenue : ${error.message}`);
    }
}
  


//   66b8e_izabellpaige158@gmail.com_bad_proxy_18308.txt



async function sleep(ms) {
    const totalSeconds = Math.ceil(ms / 1000);
    for (let i = 1; i <= totalSeconds; i++) {
        console.log(`‚è≥ Attente... ${i} seconde(s) √©coul√©e(s)`);
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
    console.log("‚úÖ Pause termin√©e !");
}
